#!/usr/bin/env python3
"""
macOS Build Script
Creates portable .app bundles using PyInstaller for x86_64 and arm64 architectures.
"""

import argparse
import hashlib
import logging
from pathlib import Path
import platform
import shutil
import subprocess
import sys
import tarfile
import urllib.request

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("macos_builder")

ROOT_DIR = Path(__file__).parent.parent.resolve()
DIST_DIR = ROOT_DIR / "dist"
BUILD_DIR = ROOT_DIR / "build"


def download_uv_executable(arch: str = "x86_64") -> Path:
    """Download the latest UV executable for macOS.

    Args:
        arch: Target architecture ('x86_64' or 'arm64').

    Returns:
        Path to the downloaded uv binary.
    """
    # Map arch names to UV's naming
    arch_map = {
        "x86_64": "x86_64",
        "arm64": "aarch64",
    }
    uv_arch = arch_map.get(arch, "x86_64")

    # Download UV standalone executable for macOS
    uv_url = (
        f"https://github.com/astral-sh/uv/releases/latest/download/uv-{uv_arch}-apple-darwin.tar.gz"
    )
    uv_tar = ROOT_DIR / "bin" / f"uv-{uv_arch}.tar.gz"
    uv_tar.parent.mkdir(parents=True, exist_ok=True)

    logger.info(f"Downloading UV executable for macOS {arch}...")
    if not uv_tar.exists():
        try:
            urllib.request.urlretrieve(uv_url, uv_tar)  # noqa: S310
        except Exception:
            logger.exception(f"Failed to download {uv_url}")
            raise

    # Extract tar.gz
    uv_bin = uv_tar.parent / "uv"
    with tarfile.open(uv_tar, "r:gz") as tar:
        # Extract only the uv binary
        for member in tar.getmembers():
            if member.name.endswith("/uv") or member.name == "uv":
                member.name = "uv"
                tar.extract(member, uv_tar.parent)
                break

    # Make executable
    uv_bin.chmod(0o755)

    return uv_bin


def check_system_requirements() -> None:
    """Verify system is macOS and has required tools."""
    if platform.system() != "Darwin":
        logger.error("This script must run on macOS to build .app bundles")
        sys.exit(1)

    # Check for required tools
    required = ["python3", "uv"]
    for tool in required:
        if not shutil.which(tool):
            logger.error(f"Required tool '{tool}' not found in PATH")
            sys.exit(1)


def install_build_dependencies() -> None:
    """Install PyInstaller and other build dependencies."""
    logger.info("Installing build dependencies...")

    packages = [
        "pyinstaller>=6.0",
        "hatchling",
        "hatch-vcs",
        "wheel",
    ]

    cmd = ["uv", "pip", "install", *packages, "--system"]
    subprocess.check_call(cmd)


def get_app_version() -> str:
    """Get application version from hatch-vcs generated file or git tags.

    Returns:
        Version string (e.g., "0.2.0" or "0.0.0-dev" on failure)
    """
    # Try reading hatch-vcs generated _version.py first (fastest)
    try:
        version_file = ROOT_DIR / "app" / "_version.py"
        if version_file.exists():
            namespace: dict[str, str] = {}
            exec(version_file.read_text(), namespace)  # noqa: S102
            version = namespace.get("__version__", "")
            if version:
                logger.info(f"Detected version from _version.py: {version}")
                return version
    except Exception as e:
        logger.debug(f"Could not read _version.py: {e}")

    # Try reading from git tags (development)
    try:
        result = subprocess.run(
            ["git", "describe", "--tags", "--abbrev=0"],
            capture_output=True,
            text=True,
            check=False,
            cwd=ROOT_DIR,
        )
        if result.returncode == 0:
            version = result.stdout.strip().lstrip("v")
            if version:
                logger.info(f"Detected version from git tags: {version}")
                return version
    except Exception as e:
        logger.debug(f"Could not get version from git: {e}")
    return "0.0.0-dev"


def generate_version_file(version: str) -> None:
    """Generate _version.py file."""
    version_file = ROOT_DIR / "app" / "_version.py"
    logger.info(f"Generating {version_file} with version {version}...")

    with version_file.open("w") as f:
        f.write(
            f"# file generated by hatch-vcs (hatchling)\n"
            f"# don't change, don't track in version control\n"
            f'__version__ = version = "{version}"\n'
            f"__version_tuple__ = version_tuple = {tuple(version.split('.'))}\n"
        )


def create_pyinstaller_spec(arch: str) -> Path:
    """Create PyInstaller spec file for the application."""
    spec_file = ROOT_DIR / "pyMM-macos.spec"

    app_name = "pyMediaManager"

    spec_content = f"""# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['launcher.py'],
    pathex=['{ROOT_DIR}'],
    binaries=[],
    datas=[
        ('app', 'app'),
        ('plugins', 'plugins'),
        ('config', 'config'),
        ('README.md', '.'),
        ('LICENSE', '.'),
    ],
    hiddenimports=[
        'PySide6',
        'PySide6.QtCore',
        'PySide6.QtGui',
        'PySide6.QtWidgets',
        'qfluentwidgets',
        'pydantic',
        'yaml',
        'psutil',
        'aiohttp',
        'rich',
        'git',
        'py7zr',
        'watchdog',
        'packaging',
        'DiskArbitration',  # macOS-specific
        'objc',  # pyobjc
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=['tkinter', 'matplotlib', 'numpy', 'scipy', 'pandas'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{app_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=False,  # UPX not recommended for macOS
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch='{arch}',
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=False,
    upx_exclude=[],
    name='{app_name}',
)

app = BUNDLE(
    coll,
    name='{app_name}.app',
    icon=None,
    bundle_identifier='org.pymmediamanager.pymediamanager',
    version='{get_app_version()}',
    info_plist={{
        'CFBundleName': '{app_name}',
        'CFBundleDisplayName': 'pyMediaManager',
        'CFBundleExecutable': '{app_name}',
        'CFBundleIdentifier': 'org.pymmediamanager.pymediamanager',
        'CFBundleVersion': '{get_app_version()}',
        'CFBundleShortVersionString': '{get_app_version()}',
        'NSHighResolutionCapable': 'True',
        'LSMinimumSystemVersion': '11.0',
        'NSRequiresAquaSystemAppearance': 'False',
        'NSPrincipalClass': 'NSApplication',
    }},
)
"""

    with spec_file.open("w") as f:
        f.write(spec_content)

    logger.info(f"Created PyInstaller spec: {spec_file}")
    return spec_file


def build_with_pyinstaller(spec_file: Path) -> Path:
    """Run PyInstaller to build the application."""
    logger.info("Building with PyInstaller...")

    cmd = [
        sys.executable,
        "-m",
        "PyInstaller",
        "--clean",
        "--noconfirm",
        str(spec_file),
    ]

    subprocess.check_call(cmd, cwd=ROOT_DIR)

    # PyInstaller output is in dist/pyMediaManager.app/
    app_bundle = DIST_DIR / "pyMediaManager.app"
    if not app_bundle.exists():
        logger.error(f"PyInstaller output not found at {app_bundle}")
        sys.exit(1)

    return app_bundle


def create_dmg(app_bundle: Path, version: str, arch: str) -> Path:
    """Create DMG installer from .app bundle."""
    dmg_name = (
        f"pyMM-v{version}-py{sys.version_info.major}.{sys.version_info.minor}-macos-{arch}.dmg"
    )
    dmg_path = DIST_DIR / dmg_name

    # Remove existing DMG if present
    if dmg_path.exists():
        dmg_path.unlink()

    logger.info(f"Creating DMG: {dmg_name}...")

    # Create a temporary directory for DMG contents
    dmg_temp = BUILD_DIR / f"dmg-{arch}"
    if dmg_temp.exists():
        shutil.rmtree(dmg_temp)
    dmg_temp.mkdir(parents=True, exist_ok=True)

    # Copy .app bundle to temp directory
    dmg_app = dmg_temp / app_bundle.name
    shutil.copytree(app_bundle, dmg_app, symlinks=True)

    # Create Applications symlink
    applications_link = dmg_temp / "Applications"
    applications_link.symlink_to("/Applications")

    # Use hdiutil to create DMG
    cmd = [
        "hdiutil",
        "create",
        str(dmg_path),
        "-volname",
        f"pyMediaManager {version}",
        "-srcfolder",
        str(dmg_temp),
        "-ov",
        "-format",
        "UDZO",  # Compressed
    ]

    subprocess.check_call(cmd)

    if not dmg_path.exists():
        logger.error(f"DMG creation failed - {dmg_path} not found")
        sys.exit(1)

    logger.info(f"âœ… DMG created: {dmg_path}")
    return dmg_path


def create_zip_archive(app_bundle: Path, version: str, arch: str) -> Path:
    """Create ZIP archive of .app bundle (alternative to DMG)."""
    zip_name = (
        f"pyMM-v{version}-py{sys.version_info.major}.{sys.version_info.minor}-macos-{arch}.zip"
    )
    zip_path = DIST_DIR / zip_name

    logger.info(f"Creating ZIP archive: {zip_name}...")

    # Use ditto to preserve macOS metadata
    cmd = [
        "ditto",
        "-c",
        "-k",
        "--sequesterRsrc",
        "--keepParent",
        str(app_bundle),
        str(zip_path),
    ]

    subprocess.check_call(cmd)

    if not zip_path.exists():
        logger.error(f"ZIP creation failed - {zip_path} not found")
        sys.exit(1)

    logger.info(f"âœ… ZIP archive created: {zip_path}")
    return zip_path


def calculate_sha256(file_path: Path) -> str:
    """Calculate SHA256 checksum of a file."""
    sha256_hash = hashlib.sha256()
    with file_path.open("rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()


def create_checksum(file_path: Path) -> Path:
    """Create SHA256 checksum file."""
    checksum = calculate_sha256(file_path)
    checksum_path = file_path.with_suffix(file_path.suffix + ".sha256")

    with checksum_path.open("w") as f:
        f.write(checksum)

    logger.info(f"âœ… Checksum created: {checksum_path}")
    logger.info(f"   SHA256: {checksum}")
    return checksum_path


def build(python_version: str, arch: str, format_type: str = "dmg") -> None:
    """Main build function."""
    logger.info(f"ðŸŽ Building macOS .app bundle for Python {python_version} ({arch})")

    check_system_requirements()
    install_build_dependencies()

    # Get version
    version = get_app_version()
    generate_version_file(version)

    # Create spec and build
    spec_file = create_pyinstaller_spec(arch)
    app_bundle = build_with_pyinstaller(spec_file)

    # Download and bundle UV executable
    try:
        uv_bin = download_uv_executable(arch)
        logger.info(f"UV executable bundled at: {uv_bin.relative_to(ROOT_DIR)}")
    except Exception as e:
        logger.warning(f"Failed to bundle UV executable: {e}")
        logger.warning("macOS distribution will not include UV")

    # Create distribution package
    if format_type == "dmg":
        package_path = create_dmg(app_bundle, version, arch)
    else:
        package_path = create_zip_archive(app_bundle, version, arch)

    # Create checksum
    create_checksum(package_path)

    logger.info(f"âœ… Build complete for Python {python_version} ({arch})")
    logger.info(f"   Output: {package_path}")


def main() -> None:
    """Parse arguments and run the macOS build process."""
    parser = argparse.ArgumentParser(description="Build macOS Application Bundle")
    parser.add_argument(
        "--version",
        default=f"{sys.version_info.major}.{sys.version_info.minor}",
        help="Python version to build for (e.g., 3.12, 3.13, 3.14)",
    )
    parser.add_argument(
        "--arch",
        choices=["x86_64", "arm64"],
        default=platform.machine(),
        help="Target architecture (x86_64 or arm64)",
    )
    parser.add_argument(
        "--format",
        choices=["dmg", "zip"],
        default="dmg",
        help="Output format (dmg or zip)",
    )
    args = parser.parse_args()

    build(args.version, args.arch, args.format)


if __name__ == "__main__":
    main()
