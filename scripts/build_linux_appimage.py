#!/usr/bin/env python3
"""
Linux AppImage Build Script
Creates portable AppImage distributions using PyInstaller.
"""

import argparse
import hashlib
import logging
import os
from pathlib import Path
import platform
import shutil
import subprocess
import sys
import urllib.request

# Setup logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s")
logger = logging.getLogger("linux_builder")

ROOT_DIR = Path(__file__).parent.parent.resolve()
DIST_DIR = ROOT_DIR / "dist"
BUILD_DIR = ROOT_DIR / "build"


def check_system_requirements() -> None:
    """Verify system is Linux and has required tools."""
    if platform.system() != "Linux":
        logger.error("This script must run on Linux to build AppImages")
        sys.exit(1)

    # Check for required tools
    required = ["python3", "uv"]
    for tool in required:
        if not shutil.which(tool):
            logger.error(f"Required tool '{tool}' not found in PATH")
            sys.exit(1)


def install_build_dependencies() -> None:
    """Install PyInstaller and other build dependencies."""
    logger.info("Installing build dependencies...")

    packages = [
        "pyinstaller>=6.0",
        "hatchling",
        "hatch-vcs",
        "wheel",
    ]

    cmd = ["uv", "pip", "install", *packages, "--system"]
    subprocess.check_call(cmd)


def get_app_version() -> str:
    """Get application version from hatch-vcs generated file or git tags.

    Returns:
        Version string (e.g., "0.2.0" or "0.0.0-dev" on failure)
    """
    # Try reading hatch-vcs generated _version.py first (fastest)
    try:
        version_file = ROOT_DIR / "app" / "_version.py"
        if version_file.exists():
            namespace: dict[str, str] = {}
            exec(version_file.read_text(), namespace)  # noqa: S102
            version = namespace.get("__version__", "")
            if version:
                logger.info(f"Detected version from _version.py: {version}")
                return version
    except Exception as e:
        logger.debug(f"Could not read _version.py: {e}")

    # Try reading from git tags (development)
    try:
        result = subprocess.run(
            ["git", "describe", "--tags", "--abbrev=0"],
            capture_output=True,
            text=True,
            check=False,
            cwd=ROOT_DIR,
        )
        if result.returncode == 0:
            version = result.stdout.strip().lstrip("v")
            if version:
                logger.info(f"Detected version from git tags: {version}")
                return version
    except Exception as e:
        logger.debug(f"Could not get version from git: {e}")
    return "0.0.0-dev"


def generate_version_file(version: str) -> None:
    """Generate _version.py file."""
    version_file = ROOT_DIR / "app" / "_version.py"
    logger.info(f"Generating {version_file} with version {version}...")

    with version_file.open("w") as f:
        f.write(
            f"# file generated by hatch-vcs (hatchling)\n"
            f"# don't change, don't track in version control\n"
            f'__version__ = version = "{version}"\n'
            f"__version_tuple__ = version_tuple = {tuple(version.split('.'))}\n"
        )


def create_pyinstaller_spec(arch: str) -> Path:
    """Create PyInstaller spec file for the application."""
    spec_file = ROOT_DIR / "pyMM.spec"

    # Determine binary name
    app_name = "pyMM"

    spec_content = f"""# -*- mode: python ; coding: utf-8 -*-

block_cipher = None

a = Analysis(
    ['launcher.py'],
    pathex=['{ROOT_DIR}'],
    binaries=[],
    datas=[
        ('app', 'app'),
        ('plugins', 'plugins'),
        ('config', 'config'),
        ('README.md', '.'),
        ('LICENSE', '.'),
    ],
    hiddenimports=[
        'PySide6',
        'PySide6.QtCore',
        'PySide6.QtGui',
        'PySide6.QtWidgets',
        'qfluentwidgets',
        'pydantic',
        'yaml',
        'psutil',
        'aiohttp',
        'rich',
        'git',
        'py7zr',
        'watchdog',
        'packaging',
        'pyudev',  # Linux-specific
    ],
    hookspath=[],
    hooksconfig={{}},
    runtime_hooks=[],
    excludes=['tkinter', 'matplotlib', 'numpy', 'scipy', 'pandas'],
    win_no_prefer_redirects=False,
    win_private_assemblies=False,
    cipher=block_cipher,
    noarchive=False,
)

pyz = PYZ(a.pure, a.zipped_data, cipher=block_cipher)

exe = EXE(
    pyz,
    a.scripts,
    [],
    exclude_binaries=True,
    name='{app_name}',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=True,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch='{arch}',
    codesign_identity=None,
    entitlements_file=None,
)

coll = COLLECT(
    exe,
    a.binaries,
    a.zipfiles,
    a.datas,
    strip=False,
    upx=True,
    upx_exclude=[],
    name='{app_name}',
)
"""

    with spec_file.open("w") as f:
        f.write(spec_content)

    logger.info(f"Created PyInstaller spec: {spec_file}")
    return spec_file


def build_with_pyinstaller(spec_file: Path) -> Path:
    """Run PyInstaller to build the application."""
    logger.info("Building with PyInstaller...")

    cmd = [
        sys.executable,
        "-m",
        "PyInstaller",
        "--clean",
        "--noconfirm",
        str(spec_file),
    ]

    subprocess.check_call(cmd, cwd=ROOT_DIR)

    # PyInstaller output is in dist/pyMM/
    app_dir = DIST_DIR / "pyMM"
    if not app_dir.exists():
        logger.error(f"PyInstaller output not found at {app_dir}")
        sys.exit(1)

    return app_dir


def create_appimage_structure(app_dir: Path, arch: str) -> Path:
    """Create AppImage directory structure."""
    appdir = BUILD_DIR / f"pyMM.AppDir-{arch}"

    if appdir.exists():
        shutil.rmtree(appdir)

    appdir.mkdir(parents=True, exist_ok=True)

    # Create standard AppImage structure
    (appdir / "usr" / "bin").mkdir(parents=True, exist_ok=True)
    (appdir / "usr" / "share" / "applications").mkdir(parents=True, exist_ok=True)
    (appdir / "usr" / "share" / "icons" / "hicolor" / "256x256" / "apps").mkdir(
        parents=True, exist_ok=True
    )

    # Copy application files
    logger.info(f"Copying application to {appdir}/usr/bin/...")
    shutil.copytree(app_dir, appdir / "usr" / "bin" / "pyMM")

    # Create AppRun script
    apprun = appdir / "AppRun"
    apprun_content = """#!/bin/bash
SELF=$(readlink -f "$0")
HERE=${SELF%/*}
export PATH="${HERE}/usr/bin:${PATH}"
export LD_LIBRARY_PATH="${HERE}/usr/lib:${LD_LIBRARY_PATH}"
cd "${HERE}/usr/bin/pyMM"
exec "${HERE}/usr/bin/pyMM/pyMM" "$@"
"""
    with apprun.open("w") as f:
        f.write(apprun_content)
    apprun.chmod(0o755)

    # Create .desktop file
    desktop_file = appdir / "pyMediaManager.desktop"
    # Desktop Entry spec requires simple version format (e.g., "1.0")
    # Strip git metadata from version string (e.g., "0.0.post247+gb8766145l" -> "1.0")
    desktop_version = "1.0"  # Use static version for desktop file spec compliance
    desktop_content = f"""[Desktop Entry]
Type=Application
Name=pyMediaManager
Comment=Portable Python-based media management application
Exec=pyMM
Icon=pymediamanager
Categories=AudioVideo;Video;Photography;
Terminal=false
Version={desktop_version}
"""
    with desktop_file.open("w") as f:
        f.write(desktop_content)

    # Copy desktop file to standard location
    shutil.copy(desktop_file, appdir / "usr" / "share" / "applications" / "pyMediaManager.desktop")

    # Create a simple placeholder icon (required by AppImage)
    icon_path = (
        appdir / "usr" / "share" / "icons" / "hicolor" / "256x256" / "apps" / "pymediamanager.png"
    )

    # Create a minimal 256x256 PNG icon using PIL
    try:
        from PIL import Image, ImageDraw, ImageFont  # noqa: PLC0415

        # Create a simple icon with "pyMM" text
        img = Image.new("RGB", (256, 256), color="#2C3E50")
        draw = ImageDraw.Draw(img)

        # Draw a simple design
        draw.rectangle([20, 20, 236, 236], outline="#3498DB", width=8)

        # Try to add text (will use default font if custom font not available)
        try:
            font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", 60)
        except Exception:
            font = ImageFont.load_default()

        # Center text
        text = "pyMM"
        bbox = draw.textbbox((0, 0), text, font=font)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]
        x = (256 - text_width) // 2
        y = (256 - text_height) // 2

        draw.text((x, y), text, fill="#ECF0F1", font=font)

        # Save the icon
        icon_path.parent.mkdir(parents=True, exist_ok=True)
        img.save(icon_path, "PNG")
        logger.info("Created placeholder icon")
    except ImportError:
        logger.warning("PIL not available - creating minimal icon")
        # Create a minimal valid PNG file (1x1 pixel) as absolute fallback
        icon_path.parent.mkdir(parents=True, exist_ok=True)
        # Minimal 1x1 transparent PNG (67 bytes)
        minimal_png = (
            b"\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01"
            b"\x08\x06\x00\x00\x00\x1f\x15\xc4\x89\x00\x00\x00\nIDATx\x9cc\x00\x01"
            b"\x00\x00\x05\x00\x01\r\n-\xb4\x00\x00\x00\x00IEND\xaeB`\x82"
        )
        icon_path.write_bytes(minimal_png)

    # Copy icon to root (required by AppImage)
    icon_root = appdir / "pymediamanager.png"
    shutil.copy(icon_path, icon_root)

    logger.info(f"AppImage directory structure created at {appdir}")
    return appdir


def download_appimagetool(arch: str) -> Path:
    """Download appimagetool if not present."""
    tools_dir = ROOT_DIR / "tools"
    tools_dir.mkdir(exist_ok=True)

    # Map architecture names
    appimagetool_arch = "x86_64" if arch == "x86_64" else "aarch64"
    tool_name = f"appimagetool-{appimagetool_arch}.AppImage"
    tool_path = tools_dir / tool_name

    if tool_path.exists():
        logger.info(f"Using cached appimagetool: {tool_path}")
        return tool_path

    url = f"https://github.com/AppImage/AppImageKit/releases/download/continuous/{tool_name}"
    logger.info(f"Downloading appimagetool from {url}...")

    try:
        urllib.request.urlretrieve(url, tool_path)  # noqa: S310
        tool_path.chmod(0o755)
        logger.info(f"Downloaded appimagetool to {tool_path}")
    except Exception:
        logger.exception(
            "Failed to download appimagetool. "
            "Please install appimagetool manually or use AppImage GitHub Action"
        )
        sys.exit(1)

    return tool_path


def create_appimage(appdir: Path, version: str, arch: str) -> Path:
    """Create AppImage from AppDir."""
    appimagetool = download_appimagetool(arch)

    output_name = (
        f"pyMM-v{version}-py{sys.version_info.major}.{sys.version_info.minor}-{arch}.AppImage"
    )
    output_path = DIST_DIR / output_name

    logger.info(f"Creating AppImage: {output_name}...")

    env = {**dict(os.environ), "ARCH": arch}
    cmd = [str(appimagetool), str(appdir), str(output_path)]

    subprocess.check_call(cmd, env=env)

    if not output_path.exists():
        logger.error(f"AppImage creation failed - {output_path} not found")
        sys.exit(1)

    logger.info(f"âœ… AppImage created: {output_path}")
    return output_path


def calculate_sha256(file_path: Path) -> str:
    """Calculate SHA256 checksum of a file."""
    sha256_hash = hashlib.sha256()
    with file_path.open("rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()


def create_checksum(appimage_path: Path) -> Path:
    """Create SHA256 checksum file."""
    checksum = calculate_sha256(appimage_path)
    checksum_path = appimage_path.with_suffix(appimage_path.suffix + ".sha256")

    with checksum_path.open("w") as f:
        f.write(checksum)

    logger.info(f"âœ… Checksum created: {checksum_path}")
    logger.info(f"   SHA256: {checksum}")
    return checksum_path


def build(python_version: str, arch: str) -> None:
    """Main build function."""
    logger.info(f"ðŸ§ Building Linux AppImage for Python {python_version} ({arch})")

    check_system_requirements()
    install_build_dependencies()

    # Get version
    version = get_app_version()
    generate_version_file(version)

    # Create spec and build
    spec_file = create_pyinstaller_spec(arch)
    app_dir = build_with_pyinstaller(spec_file)

    # Create AppImage
    appdir = create_appimage_structure(app_dir, arch)
    appimage_path = create_appimage(appdir, version, arch)

    # Create checksum
    create_checksum(appimage_path)

    logger.info(f"âœ… Build complete for Python {python_version} ({arch})")
    logger.info(f"   Output: {appimage_path}")


def main() -> None:
    """Parse arguments and run the Linux build process."""
    parser = argparse.ArgumentParser(description="Build Linux AppImage Distribution")
    parser.add_argument(
        "--version",
        default=f"{sys.version_info.major}.{sys.version_info.minor}",
        help="Python version to build for (e.g., 3.12, 3.13, 3.14)",
    )
    parser.add_argument(
        "--arch",
        choices=["x86_64", "aarch64"],
        default=platform.machine(),
        help="Target architecture (x86_64 or aarch64)",
    )
    args = parser.parse_args()

    build(args.version, args.arch)


if __name__ == "__main__":
    main()
